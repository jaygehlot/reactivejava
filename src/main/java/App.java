import io.reactivex.Observable;
import io.reactivex.schedulers.Schedulers;

import java.util.Calendar;
import java.util.Random;
import java.util.concurrent.TimeUnit;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {
    public String getGreeting() {
        return "Hello world.";
    }


    /**
     * Created a range of numbers that are emitted every so often,
     * mapped each of those numbers to an Observable, which has a random
     * delay at the start of each number, and each number is random.
     * Then we flatten, those random delays, so they all happen one after another.
     *
     * @return
     */
    public static Observable<Integer> intervalRangeWithRandomness() {
        Random random = new Random();
        return Observable.intervalRange(1, 20, 500, 500, TimeUnit.MILLISECONDS)
                .concatMap(number -> Observable.just(random.nextInt(Math.toIntExact(number))))
                                                .delay(random.nextInt(500), TimeUnit.MILLISECONDS);

        //concatMap will flatten the Observable of Observables into one Observable

        //                                                  OBSERVABLE
        // ---------------------------------------------------------------------------------------------------------------------------------------
        // | OBSERVABLE(someRandomInteger).....OBSERVABLE(someRandomInteger).....OBSERVABLE(someRandomInteger).....OBSERVABLE(someRandomInteger) |
        // ---------------------------------------------------------------------------------------------------------------------------------------
        //              |                       |                           |                               |
        //              |                       |                           |                               |
        //              \/                      \/                          \/                              \/
        //                                           CONCATMAP - flattens the above structure into the one below
        //          ---------------------------------------------------------------------------------------------------------------
    //              |                      OBSERVABLE(someRandomInteger, someRandomInteger, someRandomInteger, someRandomInteger)  |
        //          ---------------------------------------------------------------------------------------------------------------
    }

    /**
     * Will output random integers in a timely manner, every 500 milliseconds
     * and runs in its own thread
     * @return
     */
    public static Observable<Integer> intervalRange() {
        Random random = new Random();
        return Observable.intervalRange(1, 20, 500, 500, TimeUnit.MILLISECONDS)
                .map(num -> random.nextInt(Math.toIntExact(20)));
    }



    /**
     * Creates and Observable stream of events (Integers) which are used each
     * used at the top end for random creating random integers.
     * @return
     */
    public static Observable<Integer> fakeUserInput() {
        Random random = new Random();
        return Observable.just(10, 20, 30, 50, 60, 70)
                            .map(num -> random.nextInt(num));
    }


    public static Observable<Integer> useObservableRange() {
        return Observable.range(1, 5);
    }

    public static void main(String[] args) {
        //as we are now using asynchronous code, blockingSubscribe using because main thread is exiting before there
        //is time to get the output from intervalRange method, because the Timer is running in a
        //different thread
        //blockingSubscribe tells main thread to wait

        //intervalRange().blockingSubscribe(line -> System.out.println(line));

        //useObservableRange().subscribe(line -> System.out.print(line));

        //fakeUserInput().subscribe(line -> System.out.println(line));

        System.out.println("FIBONACCI==========================================");
        //flatMapMaybe allows interweaving of Observables
//        intervalRangeWithRandomness()
//                .flatMapMaybe(x -> RxFibonacci.fibs().elementAt(x))
//                .blockingSubscribe(line -> System.out.println(line));


        /**
         * Why use .observeOn or .subscribeOn? Why are these necessary?
         *
         */
        RxReader.lineFromInput()
                .map(Integer::parseInt)
                .observeOn(Schedulers.trampoline())  //trampoline() says, from we are providing a thread to run things on
                .flatMapMaybe(x -> RxFibonacci.fibs().elementAt(x))
                .blockingSubscribe(line -> System.out.println(line));


//        Observable.just("Hello World\nJay Gehlot\nToday is Saturday!")
//                .subscribe(line -> System.out.println(line));

        //stream of 1 event on the Observable, we have "subscribed to it", whenever it emits something, the
        //subscribe catches it and prints it out

    }
}
